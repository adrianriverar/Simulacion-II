# -*- coding: utf-8 -*-
"""Practica1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XlmIQwJLrCCHoB1r9nWmXlSRvUkLzWos
"""

# Adrián Rivera Ramírez - 03 Abril 2023
# Simulación II - 8MM1 - Lic. en Ing. Matemática - ESFM - IPN

#### Pruebas uniformidad e independencia para una lista de números pseudoaleatorios en [0,1]

import os
import math
import scipy
import statistics

os.system ("cls")

pseudoaleatorios = [0.78, 0.04, 0.96, 0.61, 0.43, 0.82, 0.83, 0.22, 0.83, 0.51, 0.98, 0.29, 0.26, 0.14, 0.67, 0.94, 0.88, 0.50, 0.79, 0.07,
                    0.24, 0.68, 0.91, 0.38, 0.62, 0.19, 0.18, 0.16, 0.65, 0.18, 0.73, 0.77, 0.55, 0.12, 0.32, 0.98, 0.21, 0.11, 0.28, 0.94,
                    0.43, 0.16, 0.75, 0.40, 0.53, 0.41, 0.50, 0.18, 0.78, 0.50, 0.16, 0.03, 0.55, 0.74, 0.54, 1.00, 0.13, 0.89, 0.49, 0.22,
                    0.78, 0.79, 0.64, 0.78, 0.24, 0.74, 0.43, 0.80, 0.36, 0.66, 0.47, 0.22, 0.39, 0.98, 0.29, 0.92, 0.69, 0.42, 0.86, 0.91,
                    0.18, 0.37, 0.53, 0.27, 0.18, 0.14, 0.08, 0.29, 0.87, 0.48, 0.55, 0.80, 0.45, 0.60, 0.08, 0.43, 0.12, 0.87, 0.64, 0.24]
n = len(pseudoaleatorios)
num_interval = math.ceil(math.sqrt(n))  # Número de intervalos para las pruebas de uniformidad

# Función para impresión de resultado
def resultado(prueba, critico, alpha, text1, text2):
  print('\nSegún la prueba de ' + text1 + ' con ' + str((1-alpha)*100) + '% de confianza, los números aleatorios ingresados')
  if prueba <= critico:
    print('SÍ ' + text2 + '.\n')
  else:
    print('NO ' + text2 + '.\n')






### Pruebas de uniformidad

## Prueba Chi-cuadrado

alpha = 0.1           # Ingresar grado de significancia
FE = n / num_interval  # Frecuencia de datos esperada por intervalo

# Cálculo de estadístico chi-cuadrado de prueba
X2p = 0
for i in range(num_interval):
  bucket_arr = [x for x in pseudoaleatorios if (x > i/num_interval or x == i/num_interval) and (x < (i+1)/num_interval)]                        
  bucket_num = (len(bucket_arr) - FE)**2
  X2p += bucket_num
if 1 in pseudoaleatorios:
  X2p = X2p - bucket_num + (len(bucket_arr) + len([x for x in pseudoaleatorios if x == 1]) - FE)**2
X2p = X2p / FE

X2c = scipy.stats.chi2.ppf(1-alpha, n-1)  # Estadístico chi-cuadrado crítico

# Impresión de resultado
resultado(X2p, X2c, alpha, 'bondad de ajuste Chi-cuadrado', 'se distribuyen uniformemente en [0,1]')





## Prueba Kolmogorov-Smirnov

alpha = 0.1   # Ingresar grado de significancia

# Calculando estadístico de prueba Dp para la prueba K-S
freq = []
acum = 0
for i in range(num_interval):
  acum += len([x for x in pseudoaleatorios if (x > i/num_interval or x == i/num_interval) and (x < (i+1)/num_interval)])
  freq.append(abs(acum/n - (i+1)/num_interval))
if 1 in pseudoaleatorios:
  freq[i] = 0
Dp = max(freq)

# Aproximación de estadístico Dc crítico de prueba K-S
Dc = math.sqrt(- math.log(alpha/2) / (2*n))   # (Esta fórmula se recomienda para n >= 100)

# Impresión de resultado
resultado(Dp, Dc, alpha, 'bondad de ajuste Kolmogorov-Smirnov', 'se distribuyen uniformemente en [0,1]')






### Pruebas de independencia

## Prueba de corridas

alpha = 0.05   # Ingresar grado de significancia

# Asignando signos +(1) y -(0) a cambios de r_(i-1) a r_i
corridas = []
for i in range(n-1):
  if pseudoaleatorios[i+1] > pseudoaleatorios[i]:
    corridas.append(1)
  else:
    corridas.append(0)

# Contando cuántos cambios h de signo hay
h = 0
for i in range(n-2):
  if corridas[i+1] != corridas[i]:
    h += 1

# Calculando estadístico Z para la prueba
E = (2*n - 1) / 3
V = (16*n - 29) / 90
Z = (h - E) / math.sqrt(V)

Zc = scipy.stats.norm.ppf(1 - alpha/2)  # Estadístico Zc crítico para la prueba

# Impresión de resultado
resultado(Z, Zc, alpha, 'independencia por corridas', 'son independientes entre sí')